/*
 * Trinsic API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package id.trinsic.api.models;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import id.trinsic.api.models.IntegrationLaunchMethod;
import id.trinsic.api.models.ProviderHealth;
import id.trinsic.api.models.ResultCollectionMethod;
import id.trinsic.api.models.SubProviderMetadata;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.openapitools.jackson.nullable.JsonNullable;
import java.util.NoSuchElementException;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


import id.trinsic.ApiClient;
/**
 * ProviderContract
 */
@JsonPropertyOrder({
  ProviderContract.JSON_PROPERTY_ID,
  ProviderContract.JSON_PROPERTY_NAME,
  ProviderContract.JSON_PROPERTY_DESCRIPTION,
  ProviderContract.JSON_PROPERTY_LOGO_URL,
  ProviderContract.JSON_PROPERTY_AVAILABLE,
  ProviderContract.JSON_PROPERTY_GEOGRAPHY,
  ProviderContract.JSON_PROPERTY_REGIONS,
  ProviderContract.JSON_PROPERTY_LAUNCH_METHOD,
  ProviderContract.JSON_PROPERTY_COLLECTION_METHOD,
  ProviderContract.JSON_PROPERTY_RESULTS_MAY_BE_DELAYED_AFTER_REDIRECT,
  ProviderContract.JSON_PROPERTY_HAS_REFRESHABLE_CONTENT,
  ProviderContract.JSON_PROPERTY_REQUIRES_INPUT,
  ProviderContract.JSON_PROPERTY_HAS_TRINSIC_INTERFACE,
  ProviderContract.JSON_PROPERTY_SUPPORTS_ADVANCED_PROVIDER_SESSIONS,
  ProviderContract.JSON_PROPERTY_SUB_PROVIDERS,
  ProviderContract.JSON_PROPERTY_HEALTH
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-05-22T03:15:48.156257273Z[Etc/UTC]", comments = "Generator version: 7.13.0")
public class ProviderContract {
  public static final String JSON_PROPERTY_ID = "id";
  @javax.annotation.Nonnull
  private String id;

  public static final String JSON_PROPERTY_NAME = "name";
  @javax.annotation.Nonnull
  private String name;

  public static final String JSON_PROPERTY_DESCRIPTION = "description";
  @javax.annotation.Nonnull
  private String description;

  public static final String JSON_PROPERTY_LOGO_URL = "logoUrl";
  @javax.annotation.Nonnull
  private String logoUrl;

  public static final String JSON_PROPERTY_AVAILABLE = "available";
  @javax.annotation.Nonnull
  private Boolean available;

  public static final String JSON_PROPERTY_GEOGRAPHY = "geography";
  @javax.annotation.Nonnull
  private List<String> geography = new ArrayList<>();

  public static final String JSON_PROPERTY_REGIONS = "regions";
  @javax.annotation.Nonnull
  private List<String> regions = new ArrayList<>();

  public static final String JSON_PROPERTY_LAUNCH_METHOD = "launchMethod";
  @javax.annotation.Nonnull
  private IntegrationLaunchMethod launchMethod;

  public static final String JSON_PROPERTY_COLLECTION_METHOD = "collectionMethod";
  @javax.annotation.Nonnull
  private ResultCollectionMethod collectionMethod;

  public static final String JSON_PROPERTY_RESULTS_MAY_BE_DELAYED_AFTER_REDIRECT = "resultsMayBeDelayedAfterRedirect";
  @javax.annotation.Nonnull
  private Boolean resultsMayBeDelayedAfterRedirect;

  public static final String JSON_PROPERTY_HAS_REFRESHABLE_CONTENT = "hasRefreshableContent";
  @javax.annotation.Nonnull
  private Boolean hasRefreshableContent;

  public static final String JSON_PROPERTY_REQUIRES_INPUT = "requiresInput";
  @javax.annotation.Nonnull
  private Boolean requiresInput;

  public static final String JSON_PROPERTY_HAS_TRINSIC_INTERFACE = "hasTrinsicInterface";
  @javax.annotation.Nonnull
  private Boolean hasTrinsicInterface;

  public static final String JSON_PROPERTY_SUPPORTS_ADVANCED_PROVIDER_SESSIONS = "supportsAdvancedProviderSessions";
  @javax.annotation.Nonnull
  private Boolean supportsAdvancedProviderSessions;

  public static final String JSON_PROPERTY_SUB_PROVIDERS = "subProviders";
  private JsonNullable<List<SubProviderMetadata>> subProviders = JsonNullable.<List<SubProviderMetadata>>undefined();

  public static final String JSON_PROPERTY_HEALTH = "health";
  @javax.annotation.Nonnull
  private ProviderHealth health;

  public ProviderContract() { 
  }

  public ProviderContract id(@javax.annotation.Nonnull String id) {
    this.id = id;
    return this;
  }

  /**
   * The ID of the Provider for this contract.
   * @return id
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public String getId() {
    return id;
  }


  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setId(@javax.annotation.Nonnull String id) {
    this.id = id;
  }


  public ProviderContract name(@javax.annotation.Nonnull String name) {
    this.name = name;
    return this;
  }

  /**
   * The Provider&#39;s Name as it appears in Trinsic&#39;s Dashboard and Widget
   * @return name
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public String getName() {
    return name;
  }


  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setName(@javax.annotation.Nonnull String name) {
    this.name = name;
  }


  public ProviderContract description(@javax.annotation.Nonnull String description) {
    this.description = description;
    return this;
  }

  /**
   * The Provider&#39;s description as it appears in Trinsic&#39;s Widget.              This is flavor text, not a full, human-readable description of the provider.
   * @return description
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_DESCRIPTION)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public String getDescription() {
    return description;
  }


  @JsonProperty(JSON_PROPERTY_DESCRIPTION)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setDescription(@javax.annotation.Nonnull String description) {
    this.description = description;
  }


  public ProviderContract logoUrl(@javax.annotation.Nonnull String logoUrl) {
    this.logoUrl = logoUrl;
    return this;
  }

  /**
   * A URL pointing to the Provider&#39;s logo on Trinsic&#39;s CDN.              May be a PNG, JPG, or SVG image.
   * @return logoUrl
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_LOGO_URL)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public String getLogoUrl() {
    return logoUrl;
  }


  @JsonProperty(JSON_PROPERTY_LOGO_URL)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLogoUrl(@javax.annotation.Nonnull String logoUrl) {
    this.logoUrl = logoUrl;
  }


  public ProviderContract available(@javax.annotation.Nonnull Boolean available) {
    this.available = available;
    return this;
  }

  /**
   * Whether the Provider is available for use in your App.              If &#x60;false&#x60;, you will need to contact Trinsic to enable this Provider for your App.
   * @return available
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_AVAILABLE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Boolean getAvailable() {
    return available;
  }


  @JsonProperty(JSON_PROPERTY_AVAILABLE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setAvailable(@javax.annotation.Nonnull Boolean available) {
    this.available = available;
  }


  public ProviderContract geography(@javax.annotation.Nonnull List<String> geography) {
    this.geography = geography;
    return this;
  }

  public ProviderContract addGeographyItem(String geographyItem) {
    if (this.geography == null) {
      this.geography = new ArrayList<>();
    }
    this.geography.add(geographyItem);
    return this;
  }

  /**
   * The geographies within the Regions the Provider is available.
   * @return geography
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_GEOGRAPHY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public List<String> getGeography() {
    return geography;
  }


  @JsonProperty(JSON_PROPERTY_GEOGRAPHY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setGeography(@javax.annotation.Nonnull List<String> geography) {
    this.geography = geography;
  }


  public ProviderContract regions(@javax.annotation.Nonnull List<String> regions) {
    this.regions = regions;
    return this;
  }

  public ProviderContract addRegionsItem(String regionsItem) {
    if (this.regions == null) {
      this.regions = new ArrayList<>();
    }
    this.regions.add(regionsItem);
    return this;
  }

  /**
   * The regions within which the Provider is available.
   * @return regions
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_REGIONS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public List<String> getRegions() {
    return regions;
  }


  @JsonProperty(JSON_PROPERTY_REGIONS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setRegions(@javax.annotation.Nonnull List<String> regions) {
    this.regions = regions;
  }


  public ProviderContract launchMethod(@javax.annotation.Nonnull IntegrationLaunchMethod launchMethod) {
    this.launchMethod = launchMethod;
    return this;
  }

  /**
   * Relevant only to Advanced Provider Sessions.              The &#x60;LaunchMethod&#x60; which must be supported to launch the Provider Session in Advanced Provider Sessions.
   * @return launchMethod
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_LAUNCH_METHOD)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public IntegrationLaunchMethod getLaunchMethod() {
    return launchMethod;
  }


  @JsonProperty(JSON_PROPERTY_LAUNCH_METHOD)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLaunchMethod(@javax.annotation.Nonnull IntegrationLaunchMethod launchMethod) {
    this.launchMethod = launchMethod;
  }


  public ProviderContract collectionMethod(@javax.annotation.Nonnull ResultCollectionMethod collectionMethod) {
    this.collectionMethod = collectionMethod;
    return this;
  }

  /**
   * Relevant only to Advanced Provider Sessions.              The &#x60;CollectionMethod&#x60; which must be supported to launch the Provider Session in Advanced Provider Sessions.
   * @return collectionMethod
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_COLLECTION_METHOD)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public ResultCollectionMethod getCollectionMethod() {
    return collectionMethod;
  }


  @JsonProperty(JSON_PROPERTY_COLLECTION_METHOD)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCollectionMethod(@javax.annotation.Nonnull ResultCollectionMethod collectionMethod) {
    this.collectionMethod = collectionMethod;
  }


  public ProviderContract resultsMayBeDelayedAfterRedirect(@javax.annotation.Nonnull Boolean resultsMayBeDelayedAfterRedirect) {
    this.resultsMayBeDelayedAfterRedirect = resultsMayBeDelayedAfterRedirect;
    return this;
  }

  /**
   * If &#x60;true&#x60;, then the results for this Provider may not be available immediately after the user is redirected back to your application. In this case, the &#x60;GetSessionResults&#x60; API must be called until results are available.              This is an uncommon scenario, and typically only applies to Providers which use a biometric check or traditional document scan.
   * @return resultsMayBeDelayedAfterRedirect
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_RESULTS_MAY_BE_DELAYED_AFTER_REDIRECT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Boolean getResultsMayBeDelayedAfterRedirect() {
    return resultsMayBeDelayedAfterRedirect;
  }


  @JsonProperty(JSON_PROPERTY_RESULTS_MAY_BE_DELAYED_AFTER_REDIRECT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setResultsMayBeDelayedAfterRedirect(@javax.annotation.Nonnull Boolean resultsMayBeDelayedAfterRedirect) {
    this.resultsMayBeDelayedAfterRedirect = resultsMayBeDelayedAfterRedirect;
  }


  public ProviderContract hasRefreshableContent(@javax.annotation.Nonnull Boolean hasRefreshableContent) {
    this.hasRefreshableContent = hasRefreshableContent;
    return this;
  }

  /**
   * Relevant only to Advanced Provider Sessions.              Whether the Provider requires the &#x60;RefreshStepContent&#x60; capability.              For example, Samsung Wallet&#39;s deep links expire every 30 seconds, and must be refreshed periodically for a resilient user flow.
   * @return hasRefreshableContent
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_HAS_REFRESHABLE_CONTENT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Boolean getHasRefreshableContent() {
    return hasRefreshableContent;
  }


  @JsonProperty(JSON_PROPERTY_HAS_REFRESHABLE_CONTENT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setHasRefreshableContent(@javax.annotation.Nonnull Boolean hasRefreshableContent) {
    this.hasRefreshableContent = hasRefreshableContent;
  }


  public ProviderContract requiresInput(@javax.annotation.Nonnull Boolean requiresInput) {
    this.requiresInput = requiresInput;
    return this;
  }

  /**
   * Relevant to Hosted Provider Sessions and Advanced Provider Sessions.              If &#x60;true&#x60;, this Provider requires provider-specific input on Session creation. If this input is not provided, Trinsic&#39;s Hosted UI will be invoked to collect the input from the user.
   * @return requiresInput
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_REQUIRES_INPUT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Boolean getRequiresInput() {
    return requiresInput;
  }


  @JsonProperty(JSON_PROPERTY_REQUIRES_INPUT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setRequiresInput(@javax.annotation.Nonnull Boolean requiresInput) {
    this.requiresInput = requiresInput;
  }


  public ProviderContract hasTrinsicInterface(@javax.annotation.Nonnull Boolean hasTrinsicInterface) {
    this.hasTrinsicInterface = hasTrinsicInterface;
    return this;
  }

  /**
   * Whether there exists a Trinsic-hosted UI for this Provider.              This is &#x60;true&#x60; for any Provider which is not a simple, OIDC-like redirect flow.
   * @return hasTrinsicInterface
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_HAS_TRINSIC_INTERFACE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Boolean getHasTrinsicInterface() {
    return hasTrinsicInterface;
  }


  @JsonProperty(JSON_PROPERTY_HAS_TRINSIC_INTERFACE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setHasTrinsicInterface(@javax.annotation.Nonnull Boolean hasTrinsicInterface) {
    this.hasTrinsicInterface = hasTrinsicInterface;
  }


  public ProviderContract supportsAdvancedProviderSessions(@javax.annotation.Nonnull Boolean supportsAdvancedProviderSessions) {
    this.supportsAdvancedProviderSessions = supportsAdvancedProviderSessions;
    return this;
  }

  /**
   * Whether this Provider can be fully whitelabeled/OEMed through the Advanced Provider Sessions API.              If &#x60;false&#x60;, the Provider may still be launched through Advanced Provider Sessions; however, it will necessarily require a Trinsic-hosted UI to function.
   * @return supportsAdvancedProviderSessions
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_SUPPORTS_ADVANCED_PROVIDER_SESSIONS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Boolean getSupportsAdvancedProviderSessions() {
    return supportsAdvancedProviderSessions;
  }


  @JsonProperty(JSON_PROPERTY_SUPPORTS_ADVANCED_PROVIDER_SESSIONS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSupportsAdvancedProviderSessions(@javax.annotation.Nonnull Boolean supportsAdvancedProviderSessions) {
    this.supportsAdvancedProviderSessions = supportsAdvancedProviderSessions;
  }


  public ProviderContract subProviders(@javax.annotation.Nullable List<SubProviderMetadata> subProviders) {
    this.subProviders = JsonNullable.<List<SubProviderMetadata>>of(subProviders);
    return this;
  }

  public ProviderContract addSubProvidersItem(SubProviderMetadata subProvidersItem) {
    if (this.subProviders == null || !this.subProviders.isPresent()) {
      this.subProviders = JsonNullable.<List<SubProviderMetadata>>of(new ArrayList<>());
    }
    try {
      this.subProviders.get().add(subProvidersItem);
    } catch (java.util.NoSuchElementException e) {
      // this can never happen, as we make sure above that the value is present
    }
    return this;
  }

  /**
   * Metadata about the sub-providers which are available for this Provider.              For example, Italy&#39;s SPID is a Provider which aggregates access to multiple sub-providers.
   * @return subProviders
   */
  @javax.annotation.Nullable
  @JsonIgnore
  public List<SubProviderMetadata> getSubProviders() {
        return subProviders.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_SUB_PROVIDERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<List<SubProviderMetadata>> getSubProviders_JsonNullable() {
    return subProviders;
  }
  
  @JsonProperty(JSON_PROPERTY_SUB_PROVIDERS)
  public void setSubProviders_JsonNullable(JsonNullable<List<SubProviderMetadata>> subProviders) {
    this.subProviders = subProviders;
  }

  public void setSubProviders(@javax.annotation.Nullable List<SubProviderMetadata> subProviders) {
    this.subProviders = JsonNullable.<List<SubProviderMetadata>>of(subProviders);
  }


  public ProviderContract health(@javax.annotation.Nonnull ProviderHealth health) {
    this.health = health;
    return this;
  }

  /**
   * The health for an integration to be able to successfully perform a verification session.
   * @return health
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_HEALTH)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public ProviderHealth getHealth() {
    return health;
  }


  @JsonProperty(JSON_PROPERTY_HEALTH)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setHealth(@javax.annotation.Nonnull ProviderHealth health) {
    this.health = health;
  }


  /**
   * Return true if this ProviderContract object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ProviderContract providerContract = (ProviderContract) o;
    return Objects.equals(this.id, providerContract.id) &&
        Objects.equals(this.name, providerContract.name) &&
        Objects.equals(this.description, providerContract.description) &&
        Objects.equals(this.logoUrl, providerContract.logoUrl) &&
        Objects.equals(this.available, providerContract.available) &&
        Objects.equals(this.geography, providerContract.geography) &&
        Objects.equals(this.regions, providerContract.regions) &&
        Objects.equals(this.launchMethod, providerContract.launchMethod) &&
        Objects.equals(this.collectionMethod, providerContract.collectionMethod) &&
        Objects.equals(this.resultsMayBeDelayedAfterRedirect, providerContract.resultsMayBeDelayedAfterRedirect) &&
        Objects.equals(this.hasRefreshableContent, providerContract.hasRefreshableContent) &&
        Objects.equals(this.requiresInput, providerContract.requiresInput) &&
        Objects.equals(this.hasTrinsicInterface, providerContract.hasTrinsicInterface) &&
        Objects.equals(this.supportsAdvancedProviderSessions, providerContract.supportsAdvancedProviderSessions) &&
        equalsNullable(this.subProviders, providerContract.subProviders) &&
        Objects.equals(this.health, providerContract.health);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, name, description, logoUrl, available, geography, regions, launchMethod, collectionMethod, resultsMayBeDelayedAfterRedirect, hasRefreshableContent, requiresInput, hasTrinsicInterface, supportsAdvancedProviderSessions, hashCodeNullable(subProviders), health);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ProviderContract {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    logoUrl: ").append(toIndentedString(logoUrl)).append("\n");
    sb.append("    available: ").append(toIndentedString(available)).append("\n");
    sb.append("    geography: ").append(toIndentedString(geography)).append("\n");
    sb.append("    regions: ").append(toIndentedString(regions)).append("\n");
    sb.append("    launchMethod: ").append(toIndentedString(launchMethod)).append("\n");
    sb.append("    collectionMethod: ").append(toIndentedString(collectionMethod)).append("\n");
    sb.append("    resultsMayBeDelayedAfterRedirect: ").append(toIndentedString(resultsMayBeDelayedAfterRedirect)).append("\n");
    sb.append("    hasRefreshableContent: ").append(toIndentedString(hasRefreshableContent)).append("\n");
    sb.append("    requiresInput: ").append(toIndentedString(requiresInput)).append("\n");
    sb.append("    hasTrinsicInterface: ").append(toIndentedString(hasTrinsicInterface)).append("\n");
    sb.append("    supportsAdvancedProviderSessions: ").append(toIndentedString(supportsAdvancedProviderSessions)).append("\n");
    sb.append("    subProviders: ").append(toIndentedString(subProviders)).append("\n");
    sb.append("    health: ").append(toIndentedString(health)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `id` to the URL query string
    if (getId() != null) {
      joiner.add(String.format("%sid%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getId()))));
    }

    // add `name` to the URL query string
    if (getName() != null) {
      joiner.add(String.format("%sname%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getName()))));
    }

    // add `description` to the URL query string
    if (getDescription() != null) {
      joiner.add(String.format("%sdescription%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getDescription()))));
    }

    // add `logoUrl` to the URL query string
    if (getLogoUrl() != null) {
      joiner.add(String.format("%slogoUrl%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getLogoUrl()))));
    }

    // add `available` to the URL query string
    if (getAvailable() != null) {
      joiner.add(String.format("%savailable%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getAvailable()))));
    }

    // add `geography` to the URL query string
    if (getGeography() != null) {
      for (int i = 0; i < getGeography().size(); i++) {
        joiner.add(String.format("%sgeography%s%s=%s", prefix, suffix,
            "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix),
            ApiClient.urlEncode(ApiClient.valueToString(getGeography().get(i)))));
      }
    }

    // add `regions` to the URL query string
    if (getRegions() != null) {
      for (int i = 0; i < getRegions().size(); i++) {
        joiner.add(String.format("%sregions%s%s=%s", prefix, suffix,
            "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix),
            ApiClient.urlEncode(ApiClient.valueToString(getRegions().get(i)))));
      }
    }

    // add `launchMethod` to the URL query string
    if (getLaunchMethod() != null) {
      joiner.add(String.format("%slaunchMethod%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getLaunchMethod()))));
    }

    // add `collectionMethod` to the URL query string
    if (getCollectionMethod() != null) {
      joiner.add(String.format("%scollectionMethod%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getCollectionMethod()))));
    }

    // add `resultsMayBeDelayedAfterRedirect` to the URL query string
    if (getResultsMayBeDelayedAfterRedirect() != null) {
      joiner.add(String.format("%sresultsMayBeDelayedAfterRedirect%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getResultsMayBeDelayedAfterRedirect()))));
    }

    // add `hasRefreshableContent` to the URL query string
    if (getHasRefreshableContent() != null) {
      joiner.add(String.format("%shasRefreshableContent%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getHasRefreshableContent()))));
    }

    // add `requiresInput` to the URL query string
    if (getRequiresInput() != null) {
      joiner.add(String.format("%srequiresInput%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getRequiresInput()))));
    }

    // add `hasTrinsicInterface` to the URL query string
    if (getHasTrinsicInterface() != null) {
      joiner.add(String.format("%shasTrinsicInterface%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getHasTrinsicInterface()))));
    }

    // add `supportsAdvancedProviderSessions` to the URL query string
    if (getSupportsAdvancedProviderSessions() != null) {
      joiner.add(String.format("%ssupportsAdvancedProviderSessions%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getSupportsAdvancedProviderSessions()))));
    }

    // add `subProviders` to the URL query string
    if (getSubProviders() != null) {
      for (int i = 0; i < getSubProviders().size(); i++) {
        if (getSubProviders().get(i) != null) {
          joiner.add(getSubProviders().get(i).toUrlQueryString(String.format("%ssubProviders%s%s", prefix, suffix,
          "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
        }
      }
    }

    // add `health` to the URL query string
    if (getHealth() != null) {
      joiner.add(String.format("%shealth%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getHealth()))));
    }

    return joiner.toString();
  }
}

